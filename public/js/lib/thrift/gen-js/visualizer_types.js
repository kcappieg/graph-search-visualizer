//
// Autogenerated by Thrift Compiler (0.11.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

import Thrift from "../thrift.js";

const Location = function(args) {
  this.x = null;
  this.y = null;
  if (args) {
    if (args.x !== undefined && args.x !== null) {
      this.x = args.x;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field x is unset!');
    }
    if (args.y !== undefined && args.y !== null) {
      this.y = args.y;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field y is unset!');
    }
  }
};
Location.prototype = {};
Location.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.x = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.y = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Location.prototype.write = function(output) {
  output.writeStructBegin('Location');
  if (this.x !== null && this.x !== undefined) {
    output.writeFieldBegin('x', Thrift.Type.I32, 1);
    output.writeI32(this.x);
    output.writeFieldEnd();
  }
  if (this.y !== null && this.y !== undefined) {
    output.writeFieldBegin('y', Thrift.Type.I32, 2);
    output.writeI32(this.y);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Node = function(args) {
  this.loc = null;
  this.data = null;
  if (args) {
    if (args.loc !== undefined && args.loc !== null) {
      this.loc = new Location(args.loc);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field loc is unset!');
    }
    if (args.data !== undefined && args.data !== null) {
      this.data = Thrift.copyMap(args.data, [null]);
    }
  }
};
Node.prototype = {};
Node.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.loc = new Location();
        this.loc.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.MAP) {
        var _size0 = 0;
        var _rtmp34;
        this.data = {};
        var _ktype1 = 0;
        var _vtype2 = 0;
        _rtmp34 = input.readMapBegin();
        _ktype1 = _rtmp34.ktype;
        _vtype2 = _rtmp34.vtype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          if (_i5 > 0 ) {
            if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
              input.rstack.pop();
            }
          }
          var key6 = null;
          var val7 = null;
          key6 = input.readString().value;
          val7 = input.readString().value;
          this.data[key6] = val7;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Node.prototype.write = function(output) {
  output.writeStructBegin('Node');
  if (this.loc !== null && this.loc !== undefined) {
    output.writeFieldBegin('loc', Thrift.Type.STRUCT, 1);
    this.loc.write(output);
    output.writeFieldEnd();
  }
  if (this.data !== null && this.data !== undefined) {
    output.writeFieldBegin('data', Thrift.Type.MAP, 2);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.data));
    for (var kiter8 in this.data)
    {
      if (this.data.hasOwnProperty(kiter8))
      {
        var viter9 = this.data[kiter8];
        output.writeString(kiter8);
        output.writeString(viter9);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Iteration = function(args) {
  this.agentLocation = null;
  this.clearPreviousEnvelope = null;
  this.newEnvelopeNodes = null;
  this.clearPreviousBackup = null;
  this.newBackedUpNodes = null;
  this.addToProjectedPath = null;
  this.removeFromProjectedPath = null;
  if (args) {
    if (args.agentLocation !== undefined && args.agentLocation !== null) {
      this.agentLocation = new Location(args.agentLocation);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field agentLocation is unset!');
    }
    if (args.clearPreviousEnvelope !== undefined && args.clearPreviousEnvelope !== null) {
      this.clearPreviousEnvelope = args.clearPreviousEnvelope;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field clearPreviousEnvelope is unset!');
    }
    if (args.newEnvelopeNodes !== undefined && args.newEnvelopeNodes !== null) {
      this.newEnvelopeNodes = Thrift.copyList(args.newEnvelopeNodes, [Node]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field newEnvelopeNodes is unset!');
    }
    if (args.clearPreviousBackup !== undefined && args.clearPreviousBackup !== null) {
      this.clearPreviousBackup = args.clearPreviousBackup;
    }
    if (args.newBackedUpNodes !== undefined && args.newBackedUpNodes !== null) {
      this.newBackedUpNodes = Thrift.copyList(args.newBackedUpNodes, [Node]);
    }
    if (args.addToProjectedPath !== undefined && args.addToProjectedPath !== null) {
      this.addToProjectedPath = Thrift.copyList(args.addToProjectedPath, [Location]);
    }
    if (args.removeFromProjectedPath !== undefined && args.removeFromProjectedPath !== null) {
      this.removeFromProjectedPath = Thrift.copyList(args.removeFromProjectedPath, [Location]);
    }
  }
};
Iteration.prototype = {};
Iteration.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.agentLocation = new Location();
        this.agentLocation.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.clearPreviousEnvelope = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.SET) {
        var _size10 = 0;
        var _rtmp314;
        this.newEnvelopeNodes = [];
        var _etype13 = 0;
        _rtmp314 = input.readSetBegin();
        _etype13 = _rtmp314.etype;
        _size10 = _rtmp314.size;
        for (var _i15 = 0; _i15 < _size10; ++_i15)
        {
          var elem16 = null;
          elem16 = new Node();
          elem16.read(input);
          this.newEnvelopeNodes.push(elem16);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.BOOL) {
        this.clearPreviousBackup = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.SET) {
        var _size17 = 0;
        var _rtmp321;
        this.newBackedUpNodes = [];
        var _etype20 = 0;
        _rtmp321 = input.readSetBegin();
        _etype20 = _rtmp321.etype;
        _size17 = _rtmp321.size;
        for (var _i22 = 0; _i22 < _size17; ++_i22)
        {
          var elem23 = null;
          elem23 = new Node();
          elem23.read(input);
          this.newBackedUpNodes.push(elem23);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.SET) {
        var _size24 = 0;
        var _rtmp328;
        this.addToProjectedPath = [];
        var _etype27 = 0;
        _rtmp328 = input.readSetBegin();
        _etype27 = _rtmp328.etype;
        _size24 = _rtmp328.size;
        for (var _i29 = 0; _i29 < _size24; ++_i29)
        {
          var elem30 = null;
          elem30 = new Location();
          elem30.read(input);
          this.addToProjectedPath.push(elem30);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.SET) {
        var _size31 = 0;
        var _rtmp335;
        this.removeFromProjectedPath = [];
        var _etype34 = 0;
        _rtmp335 = input.readSetBegin();
        _etype34 = _rtmp335.etype;
        _size31 = _rtmp335.size;
        for (var _i36 = 0; _i36 < _size31; ++_i36)
        {
          var elem37 = null;
          elem37 = new Location();
          elem37.read(input);
          this.removeFromProjectedPath.push(elem37);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Iteration.prototype.write = function(output) {
  output.writeStructBegin('Iteration');
  if (this.agentLocation !== null && this.agentLocation !== undefined) {
    output.writeFieldBegin('agentLocation', Thrift.Type.STRUCT, 1);
    this.agentLocation.write(output);
    output.writeFieldEnd();
  }
  if (this.clearPreviousEnvelope !== null && this.clearPreviousEnvelope !== undefined) {
    output.writeFieldBegin('clearPreviousEnvelope', Thrift.Type.BOOL, 2);
    output.writeBool(this.clearPreviousEnvelope);
    output.writeFieldEnd();
  }
  if (this.newEnvelopeNodes !== null && this.newEnvelopeNodes !== undefined) {
    output.writeFieldBegin('newEnvelopeNodes', Thrift.Type.SET, 3);
    output.writeSetBegin(Thrift.Type.STRUCT, this.newEnvelopeNodes.length);
    for (var iter38 in this.newEnvelopeNodes)
    {
      if (this.newEnvelopeNodes.hasOwnProperty(iter38))
      {
        iter38 = this.newEnvelopeNodes[iter38];
        iter38.write(output);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  if (this.clearPreviousBackup !== null && this.clearPreviousBackup !== undefined) {
    output.writeFieldBegin('clearPreviousBackup', Thrift.Type.BOOL, 4);
    output.writeBool(this.clearPreviousBackup);
    output.writeFieldEnd();
  }
  if (this.newBackedUpNodes !== null && this.newBackedUpNodes !== undefined) {
    output.writeFieldBegin('newBackedUpNodes', Thrift.Type.SET, 5);
    output.writeSetBegin(Thrift.Type.STRUCT, this.newBackedUpNodes.length);
    for (var iter39 in this.newBackedUpNodes)
    {
      if (this.newBackedUpNodes.hasOwnProperty(iter39))
      {
        iter39 = this.newBackedUpNodes[iter39];
        iter39.write(output);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  if (this.addToProjectedPath !== null && this.addToProjectedPath !== undefined) {
    output.writeFieldBegin('addToProjectedPath', Thrift.Type.SET, 6);
    output.writeSetBegin(Thrift.Type.STRUCT, this.addToProjectedPath.length);
    for (var iter40 in this.addToProjectedPath)
    {
      if (this.addToProjectedPath.hasOwnProperty(iter40))
      {
        iter40 = this.addToProjectedPath[iter40];
        iter40.write(output);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  if (this.removeFromProjectedPath !== null && this.removeFromProjectedPath !== undefined) {
    output.writeFieldBegin('removeFromProjectedPath', Thrift.Type.SET, 7);
    output.writeSetBegin(Thrift.Type.STRUCT, this.removeFromProjectedPath.length);
    for (var iter41 in this.removeFromProjectedPath)
    {
      if (this.removeFromProjectedPath.hasOwnProperty(iter41))
      {
        iter41 = this.removeFromProjectedPath[iter41];
        iter41.write(output);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const IterationBundle = function(args) {
  this.iterations = null;
  this.bufferIsFlushed = null;
  if (args) {
    if (args.iterations !== undefined && args.iterations !== null) {
      this.iterations = Thrift.copyList(args.iterations, [Iteration]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field iterations is unset!');
    }
    if (args.bufferIsFlushed !== undefined && args.bufferIsFlushed !== null) {
      this.bufferIsFlushed = args.bufferIsFlushed;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field bufferIsFlushed is unset!');
    }
  }
};
IterationBundle.prototype = {};
IterationBundle.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size42 = 0;
        var _rtmp346;
        this.iterations = [];
        var _etype45 = 0;
        _rtmp346 = input.readListBegin();
        _etype45 = _rtmp346.etype;
        _size42 = _rtmp346.size;
        for (var _i47 = 0; _i47 < _size42; ++_i47)
        {
          var elem48 = null;
          elem48 = new Iteration();
          elem48.read(input);
          this.iterations.push(elem48);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.bufferIsFlushed = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

IterationBundle.prototype.write = function(output) {
  output.writeStructBegin('IterationBundle');
  if (this.iterations !== null && this.iterations !== undefined) {
    output.writeFieldBegin('iterations', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.iterations.length);
    for (var iter49 in this.iterations)
    {
      if (this.iterations.hasOwnProperty(iter49))
      {
        iter49 = this.iterations[iter49];
        iter49.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.bufferIsFlushed !== null && this.bufferIsFlushed !== undefined) {
    output.writeFieldBegin('bufferIsFlushed', Thrift.Type.BOOL, 2);
    output.writeBool(this.bufferIsFlushed);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const Init = function(args) {
  this.width = null;
  this.height = null;
  this.start = null;
  this.goals = null;
  this.blockedCells = null;
  if (args) {
    if (args.width !== undefined && args.width !== null) {
      this.width = args.width;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field width is unset!');
    }
    if (args.height !== undefined && args.height !== null) {
      this.height = args.height;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field height is unset!');
    }
    if (args.start !== undefined && args.start !== null) {
      this.start = new Location(args.start);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field start is unset!');
    }
    if (args.goals !== undefined && args.goals !== null) {
      this.goals = Thrift.copyList(args.goals, [Location]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field goals is unset!');
    }
    if (args.blockedCells !== undefined && args.blockedCells !== null) {
      this.blockedCells = Thrift.copyList(args.blockedCells, [Location]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field blockedCells is unset!');
    }
  }
};
Init.prototype = {};
Init.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.width = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.height = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.start = new Location();
        this.start.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size50 = 0;
        var _rtmp354;
        this.goals = [];
        var _etype53 = 0;
        _rtmp354 = input.readListBegin();
        _etype53 = _rtmp354.etype;
        _size50 = _rtmp354.size;
        for (var _i55 = 0; _i55 < _size50; ++_i55)
        {
          var elem56 = null;
          elem56 = new Location();
          elem56.read(input);
          this.goals.push(elem56);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.SET) {
        var _size57 = 0;
        var _rtmp361;
        this.blockedCells = [];
        var _etype60 = 0;
        _rtmp361 = input.readSetBegin();
        _etype60 = _rtmp361.etype;
        _size57 = _rtmp361.size;
        for (var _i62 = 0; _i62 < _size57; ++_i62)
        {
          var elem63 = null;
          elem63 = new Location();
          elem63.read(input);
          this.blockedCells.push(elem63);
        }
        input.readSetEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Init.prototype.write = function(output) {
  output.writeStructBegin('Init');
  if (this.width !== null && this.width !== undefined) {
    output.writeFieldBegin('width', Thrift.Type.I32, 1);
    output.writeI32(this.width);
    output.writeFieldEnd();
  }
  if (this.height !== null && this.height !== undefined) {
    output.writeFieldBegin('height', Thrift.Type.I32, 2);
    output.writeI32(this.height);
    output.writeFieldEnd();
  }
  if (this.start !== null && this.start !== undefined) {
    output.writeFieldBegin('start', Thrift.Type.STRUCT, 3);
    this.start.write(output);
    output.writeFieldEnd();
  }
  if (this.goals !== null && this.goals !== undefined) {
    output.writeFieldBegin('goals', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.goals.length);
    for (var iter64 in this.goals)
    {
      if (this.goals.hasOwnProperty(iter64))
      {
        iter64 = this.goals[iter64];
        iter64.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.blockedCells !== null && this.blockedCells !== undefined) {
    output.writeFieldBegin('blockedCells', Thrift.Type.SET, 5);
    output.writeSetBegin(Thrift.Type.STRUCT, this.blockedCells.length);
    for (var iter65 in this.blockedCells)
    {
      if (this.blockedCells.hasOwnProperty(iter65))
      {
        iter65 = this.blockedCells[iter65];
        iter65.write(output);
      }
    }
    output.writeSetEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

const NoDataException = function(args) {
};
Thrift.inherits(NoDataException, Thrift.TException);
NoDataException.prototype.name = 'NoDataException';
NoDataException.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NoDataException.prototype.write = function(output) {
  output.writeStructBegin('NoDataException');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

export {Location, Node, Iteration, IterationBundle, Init, NoDataException};